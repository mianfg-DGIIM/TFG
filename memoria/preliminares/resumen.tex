% !TeX root = ../libro.tex
% !TeX encoding = utf8
%
%*******************************************************
% Introducción
%*******************************************************

% \manualmark
% \markboth{\textsc{Introducción}}{\textsc{Introducción}} 
\chapter{Resumen}

%De acuerdo con la comisión de grado, el TFG debe incluir una introducción en la que se describan claramente los objetivos previstos inicialmente en la propuesta de TFG, indicando si han sido o no alcanzados, los antecedentes importantes para el desarrollo, los resultados obtenidos, en su caso y las principales fuentes consultadas.

%En este capítulo, resumiremos el proceso que hemos seguido hasta llegar a la demostración, desde una perspectiva algorítmica, del Primer Teorema de Incompletitud. En la \cref{fig:resumen}, se puede observar un esquema resumen de este trabajo, el cual es extendido en la \cref{fig:resumen-extendido}. En este resumen final se omiten las \cref{part:introduccion,,part:conclusion}.

Comenzamos este Trabajo de Fin de Grado con el \cref{ch:motivacion}, que destaca la motivación que subyace este trabajo, así como los objetivos que se pretenden cumplir. Inmediatamente después, en el \cref{ch:historia}, hacemos una breve contextualización histórica de esta obra.

El desarrollo teórico comienza con el \cref{ch:programas-python-maquinas-turing}, en cuya \cref{sec:programas-python} introducimos una clase específica de programas en Python, los \emph{programas SISO}, y observamos que esta clase es tan expresiva como la clase de todos los programas en Python. A continuación, en la \cref{sec:maquinas-turing}, profundizamos en las \emph{máquinas de Turing}, herramienta matemática principal de nuestro trabajo. En la \cref{sec:equivalencia}, introducimos nuevos modelos de computación equivalentes, hasta llegar al resultado principal del capítulo: que las máquinas de Turing pueden simular programas en Python, y viceversa; en otras palabras, que los programas en Python y las máquinas de Turing son equivalentes. Esto nos permitirá usar programas en Python convenientemente, sin realizar descripciones de máquinas de Turing. Concluimos introduciendo la tesis de Church-Turing en la \cref{sec:church-turing}, y viendo que la equivalencia probada puede ser un argumento a su favor.

En la \cref{sec:problemas-decidibles} definimos los \emph{problemas computacionales}, y observamos que los programas en Python (y, equivalentemente, las máquinas de Turing), pueden resolverlos. Llamamos \emph{decidibles} a aquellos problemas que pueden resolverse mediante un programa que nunca para. En la \cref{sec:universalidad} observamos que un programa puede simularse a sí mismo, lo cual nos conduce en la \cref{sec:problemas-no-decidibles} a la existencia de problemas no decidibles. En la \cref{sec:problemas-semidecidibles} relajamos la condición de parada para obtener problemas \emph{semidecidibles}. A continuación, introducimos en la \cref{sec:reducciones} la técnica de \emph{reducción}, que nos permite obtener nuevos problemas no decidibles, incluyendo el más importante del trabajo en la \cref{sec:problema-parada}: el \emph{problema de la parada}.

Para demostrar el teorema principal de este trabajo, es necesario formalizar los conceptos de \emph{demostración} y \emph{verdad}. Hacemos esto introduciendo los \emph{sistemas formales} en la \cref{sec:sistemas-formales} y los \emph{sistemas lógicos} en la \cref{sec:sistemas-logicos}. Los sistemas formales son \emph{sintácticos}: formalizan qué es un \emph{teorema}, una \emph{fórmula} demostrable a partir de un conjunto de \emph{axiomas} y \emph{reglas de inferencia}. Por otro lado, los sistemas lógicos incorporan a los sistemas formales un componente semántico: la \emph{verdad}. En las \cref{sec:solidez-completitud-decidibilidad,,sec:consistencia} presentamos propiedades esenciales de los sistemas mencionados, que relacionan los conceptos semánticos y sintácticos. Destacamos en la \cref{sec:aritmetica-peano} la introducción de la \emph{aritmética de Peano}: un sistema lógico de especial importancia.

Como culmen, en el \cref{ch:teorema-incompletitud} demostramos el Primer Teorema de Incompletitud: primero desde la aritmética de Peano en la \cref{sec:primera-aproximacion}, para luego generalizarlo mediante dos versiones. La primera, semántica, es demostrada en la \cref{sec:version-semantica}, y nos permite (bajo unas hipótesis computacionales) encontrar afirmaciones ciertas e indemostrables en sistemas lógicos. A continuación, la versión sintáctica de la \cref{sec:version-sintactica}, más cercana a la de Gödel, nos conduce a la existencia de sentencias indemostrables en sistemas formales. Finalizamos con la \cref{sec:consecuencias}, estudiando importantes consecuencias matemáticas (\cref{subsec:segundo-problema-hilbert}) y filosóficas (\cref{subsec:mente-humana-tesis-church-turing}).

Finalmente, terminamos con algunas conclusiones en el \cref{ch:conclusiones}, y dedicando unas palabras finales para el trabajo posterior en el \cref{ch:trabajo-futuro}.


%\vfill
% ====================
%\begin{figure}[H]
%\centering
%\vspace{8pt}
%\hspace*{-1cm}
%\centerline{\input{fig/resumen}}
%\caption{Esquema resumen}
%\label{fig:resumen}
%\end{figure}
% ====================
%\vfill

\begin{landscape}
% ====================
\begin{figure}[H]
%\captionsetup{margin=200cm}

\centering
%\vspace{-1.5cm}
%\hspace{-1cm}
%\input{fig/resumen-extendido}
\raisebox{-15.5cm}[0pt][0pt]{%
\resizebox{\linewidth}{!}{\input{fig/resumen-extendido}}
}
%\caption{Esquema resumen (extendido)}

%\label{fig:resumen-extendido}
\end{figure}
% ====================
\end{landscape}

\endinput
